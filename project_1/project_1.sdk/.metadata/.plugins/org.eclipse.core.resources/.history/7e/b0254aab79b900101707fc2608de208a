#include "xparameters.h"
#include "stdio.h"
#include "xil_exception.h"
#include "unistd.h"

#include "xuartps.h"	// if PS uart is used
#include "xscutimer.h"  // if PS Timer is used
#include "xdmaps.h"		// if PS DMA is used
#include "xscugic.h" 	// if PS GIC is used
#include "xil_exception.h"	// if interrupt is used
#include "xil_printf.h"

#include "xtime_l.h"


#define RESET_LOOP_COUNT	10	// Number of times to check reset is done
#define LENGTH 8192 // source and destination buffers lengths in number of words

#define OCM_MEMORY XPAR_PS7_OCMC_0_S_AXI_BASEADDR
#define BRAM_MEMORY0 XPAR_AXI_BRAM_CTRL_0_S_AXI_BASEADDR
#define BRAM_MEMORY1 XPAR_AXI_BRAM_CTRL_1_S_AXI_BASEADDR
#define DDR_MEMORY XPAR_PS7_DDR_0_S_AXI_BASEADDR+0x00020000 // pass all code and data sections

#define TIMER_DEVICE_ID	XPAR_SCUTIMER_DEVICE_ID
#define TIMER_LOAD_VALUE 0xFFFFFFFF
#define DMA0_ID XPAR_XDMAPS_1_DEVICE_ID
#define INTC_DEVICE_INT_ID XPAR_SCUGIC_SINGLE_DEVICE_ID

volatile static int Done = 0;	/* Dma transfer is done */
volatile static int Error = 0;	/* Dma Bus Error occurs */

int debug_flag = 1;		// 1 to print debug message, 0 ffor silent mode (profiling)

XUartPs Uart_PS;		/* Instance of the UART Device */
XScuTimer Timer;		/* Cortex A9 SCU Private Timer Instance */
XDmaPs Dma;				/* PS DMA */
XScuGic Gic;			/* PS GIC */

XScuTimer_Config *ConfigPtr;
XScuTimer *TimerInstancePtr = &Timer;

// PS Interrupt related definitions
XScuGic_Config *GicConfig;

XDmaPs_Config *DmaCfg;


//int DmaPs_Start(XDmaPs *InstPtr, unsigned int Channel,
//		  XDmaPs_Cmd *Cmd,
//		  int HoldDmaProg);

void DmaDoneHandler(unsigned int Channel,
		    XDmaPs_Cmd *DmaCmd,
		    void *CallbackRef)
{
	/* done handler */
  	Done = 1;
}

void DmaFaultHandler(unsigned int Channel,
		     XDmaPs_Cmd *DmaCmd,
		     void *CallbackRef)
{
	/* fault handler */

	Error = 1;
}



void fourbyfour_sw(const uint64_t *in_u64, uint64_t *out_u64, int n_in) {
    // 4 條各自的 16 級移位暫存器
    int16_t a[4][16] = {0};
    int out_idx = 0;
	int8_t c[4][16];
	int8_t temp = 1;
	for(int i = 0;i<4;i++){
		for(int j = 0;j<16;j++){

			c[i][j] = temp;
			temp++;
		}
	}
    for (int k = 0; k < n_in; ++k) {
    	//w = {a0,a1,a2,a3}
        uint64_t w = in_u64[k];
        int16_t a0 = (int16_t)(w >> 48);
        int16_t a1 = (int16_t)(w >> 32);
        int16_t a2 = (int16_t)(w >> 16);
        int16_t a3 = (int16_t)(w >>  0);

        // shift reg
        for (int t = 15; t > 0; --t) {
            a[0][t] = a[0][t-1];
            a[1][t] = a[1][t-1];
            a[2][t] = a[2][t-1];
            a[3][t] = a[3][t-1];
        }
        a[0][0] = a0; a[1][0] = a1; a[2][0] = a2; a[3][0] = a3;


        int16_t mac[16] = {0};

        for (int p = 0; p < 16; ++p) {
            mac[0] += (a[0][p] * c[0][15-p]);//1~16
            mac[1] += a[1][p] * c[0][15-p];
            mac[2] += a[2][p] * c[0][15-p];
            mac[3] += a[3][p] * c[0][15-p];

            mac[4] += a[0][p] * c[1][15-p];//17~32
            mac[5] += a[1][p] * c[1][15-p];
            mac[6] += a[2][p] * c[1][15-p];
            mac[7] += a[3][p] * c[1][15-p];

            mac[8] += a[0][p] * c[2][15-p];//33~48
            mac[9] += a[1][p] * c[2][15-p];
            mac[10] += a[2][p]* c[2][15-p];
            mac[11] += a[3][p]* c[2][15-p];

            mac[12] += a[0][p]* c[3][15-p];//49~64
            mac[13] += a[1][p]* c[3][15-p];
            mac[14] += a[2][p]* c[3][15-p];
            mac[15] += a[3][p]* c[3][15-p];
        }

        // shift 4
        int16_t o0 = (mac[0] + mac[1] + mac[2] + mac[3])>>4;
        int16_t o1 = (mac[4] + mac[5] + mac[6] + mac[7])>>4;
        int16_t o2 = (mac[8] + mac[9] + mac[10] + mac[11])>>4;
        int16_t o3 = (mac[12] + mac[13] + mac[14] + mac[15])>>4;


        // out = {out0,out1,out2,out3}
        uint64_t pack =
            ((uint64_t)(uint16_t)o0 << 48) |
            ((uint64_t)(uint16_t)o1 << 32) |
            ((uint64_t)(uint16_t)o2 << 16) |
            ((uint64_t)(uint16_t)o3 <<  0);

        out_u64[out_idx++] = pack;
    }
}





int SetupIntrSystem(XScuGic *GicPtr, XDmaPs *DmaPtr)
{
	int Status;

	Xil_ExceptionInit();

	// Connect the interrupt controller interrupt handler to the hardware
	// interrupt handling logic in the processor.
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT,
			     (Xil_ExceptionHandler)XScuGic_InterruptHandler,
			     GicPtr);

	// Connect a device driver handler that will be called when an interrupt
	// for the device occurs, the device driver handler performs the specific
	// interrupt processing for the device

	// Connect the Fault ISR
	Status = XScuGic_Connect(GicPtr,
				 XPAR_XDMAPS_0_FAULT_INTR,
				 (Xil_InterruptHandler)XDmaPs_FaultISR,
				 (void *)DmaPtr);
	if (Status != XST_SUCCESS)
		return XST_FAILURE;

	// Connect the Done ISR for channel 0 of DMA 0
	Status = XScuGic_Connect(GicPtr,
				 XPAR_XDMAPS_0_DONE_INTR_0,
				 (Xil_InterruptHandler)XDmaPs_DoneISR_0,
				 (void *)DmaPtr);

	if (Status != XST_SUCCESS)
		return XST_FAILURE;

	// Enable the interrupt for the device
	XScuGic_Enable(GicPtr, XPAR_XDMAPS_0_DONE_INTR_0);

	return XST_SUCCESS;
}

int MoveDataCPU(u32 * source, u32 * destination, int num) {
	volatile u32 CntValue1;
    int i;

	// reset timer
	XScuTimer_RestartTimer(TimerInstancePtr);

	// start moving data through the processor - no CDMA, no interrupt
	// gives base consumed cycles
	for (i=0; i<num; i++)
		*(destination+i) = *(source+i);

	CntValue1 = XScuTimer_GetCounterValue(TimerInstancePtr);

	return CntValue1;
}


int MoveDataDMA64(u64 * source, u64 * destination, int num) {
    int Status;
	volatile u32 CntValue1;

	// PS DMA related definitions

	XDmaPs_Cmd DmaCmd = {
		.ChanCtrl = {
			.SrcBurstSize = 4,
			.SrcBurstLen = 4,
			.SrcInc = 1,		// increment source address
			.DstBurstSize = 4,
			.DstBurstLen = 4,
			.DstInc = 1,		// increment destination address
		},
	};
	unsigned int Channel = 0;


	// Setup DMA Controller
	DmaCfg = XDmaPs_LookupConfig(DMA0_ID);
	if (!DmaCfg) {
		xil_printf("Lookup DMAC %d failed\r\n", DMA0_ID);
		return XST_FAILURE;
	}

	Status = XDmaPs_CfgInitialize(&Dma,DmaCfg,DmaCfg->BaseAddress);

	if (Status) {
		xil_printf("XDmaPs_CfgInitialize failed\r\n");
		return XST_FAILURE;
	}

	// DMA in polling mode
//		print("Starting transfer through DMA in poll mode\r\n");
		DmaCmd.BD.SrcAddr = (u32)source;
		DmaCmd.BD.DstAddr = (u32)destination;
		DmaCmd.BD.Length = num * sizeof(u64);

	// setting up for interrupt driven DMA


		if (debug_flag)
			print("Setting up interrupt system\r\n");

		Status = SetupIntrSystem(&Gic, &Dma);
		if (Status != XST_SUCCESS) {
			return XST_FAILURE;
		}

		Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ);

		XDmaPs_SetDoneHandler(&Dma,0,DmaDoneHandler,0);
		Status = XDmaPs_Start(&Dma, Channel, &DmaCmd, 0);	// release DMA buffer as we are done

		// reset timer
		XScuTimer_RestartTimer(TimerInstancePtr);

		while ((Done==0) & (Error==0));

		if (Error)
			print("Error occurred during DMA transfer\r\n");

		CntValue1 = XScuTimer_GetCounterValue(TimerInstancePtr);

		if (debug_flag)
			print("Transfer complete\r\n");
		// Disable the interrupt for the device
		XScuGic_Disable(&Gic, XPAR_XDMAPS_0_DONE_INTR_0);

		Error = 0;
		Done = 0;
		return CntValue1;
}



int MoveDataDMA32(u32 * source, u32 * destination, int num) {
    int Status;
	volatile u32 CntValue1;

	// PS DMA related definitions

	XDmaPs_Cmd DmaCmd = {
		.ChanCtrl = {
			.SrcBurstSize = 4,
			.SrcBurstLen = 4,
			.SrcInc = 1,		// increment source address
			.DstBurstSize = 4,
			.DstBurstLen = 4,
			.DstInc = 1,		// increment destination address
		},
	};
	unsigned int Channel = 0;


	// Setup DMA Controller
	DmaCfg = XDmaPs_LookupConfig(DMA0_ID);
	if (!DmaCfg) {
		xil_printf("Lookup DMAC %d failed\r\n", DMA0_ID);
		return XST_FAILURE;
	}

	Status = XDmaPs_CfgInitialize(&Dma,DmaCfg,DmaCfg->BaseAddress);

	if (Status) {
		xil_printf("XDmaPs_CfgInitialize failed\r\n");
		return XST_FAILURE;
	}

	// DMA in polling mode
//		print("Starting transfer through DMA in poll mode\r\n");
		DmaCmd.BD.SrcAddr = (u32)source;
		DmaCmd.BD.DstAddr = (u32)destination;
		DmaCmd.BD.Length = num * sizeof(u32);

	// setting up for interrupt driven DMA


		if (debug_flag)
			print("Setting up interrupt system\r\n");

		Status = SetupIntrSystem(&Gic, &Dma);
		if (Status != XST_SUCCESS) {
			return XST_FAILURE;
		}

		Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ);

		XDmaPs_SetDoneHandler(&Dma,0,DmaDoneHandler,0);
		Status = XDmaPs_Start(&Dma, Channel, &DmaCmd, 0);	// release DMA buffer as we are done

		// reset timer
		XScuTimer_RestartTimer(TimerInstancePtr);

		while ((Done==0) & (Error==0));

		if (Error)
			print("Error occurred during DMA transfer\r\n");

		CntValue1 = XScuTimer_GetCounterValue(TimerInstancePtr);

		if (debug_flag)
			print("Transfer complete\r\n");
		// Disable the interrupt for the device
		XScuGic_Disable(&Gic, XPAR_XDMAPS_0_DONE_INTR_0);

		Error = 0;
		Done = 0;
		return CntValue1;
}

int main (void) {

	// UART related definitions
    int Status;
	XUartPs_Config *Config;

	// Initialize UART
	// Look up the configuration in the config table, then initialize it.
	Config = XUartPs_LookupConfig(XPAR_XUARTPS_0_DEVICE_ID);
	if (NULL == Config) {
		return XST_FAILURE;
	}

	Status = XUartPs_CfgInitialize(&Uart_PS, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Initialize timer counter
	ConfigPtr = XScuTimer_LookupConfig(TIMER_DEVICE_ID);

	Status = XScuTimer_CfgInitialize(TimerInstancePtr, ConfigPtr,
				 ConfigPtr->BaseAddr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Initialize GIC
	GicConfig = XScuGic_LookupConfig(INTC_DEVICE_INT_ID);
	if (NULL == GicConfig) {
		xil_printf("XScuGic_LookupConfig(%d) failed\r\n",
				INTC_DEVICE_INT_ID);
		return XST_FAILURE;
	}

	Status = XScuGic_CfgInitialize(&Gic, GicConfig,
				       GicConfig->CpuBaseAddress);
	if (Status != XST_SUCCESS) {
		xil_printf("XScuGic_CfgInitialize failed\r\n");
		return XST_FAILURE;
	}

	// Set options for timer/counter 0
	// Load the timer counter register.
	XScuTimer_LoadTimer(TimerInstancePtr, TIMER_LOAD_VALUE);

	// Start the Scu Private Timer device.
	XScuTimer_Start(TimerInstancePtr);


	if (debug_flag)
		print("-- Memory Copy Performance test --\r\n");


	// Number of words you want to transfer: between 1 and 8192

	u64 *inputa;
	u64 *HardwareOutput;
	u64 *SoftwareOutput;
	int input_num = 256;
	inputa = (u64 *) DDR_MEMORY + 0x00010000;
	HardwareOutput = (u64 *) inputa + (sizeof(u64)*input_num);
	SoftwareOutput = (u64 *) HardwareOutput + (sizeof(u64)*input_num);


	u64 *bram_a_destination;
	u64 *bram_out0_destination;
	bram_a_destination = (u64 *) BRAM_MEMORY0;
	bram_out0_destination = (u64 *) BRAM_MEMORY1;

	unsigned long long temp = 1;
	unsigned long long one = 1;

    for ( int i = 1 ; i <= input_num ; i++ ){
    	unsigned long long cur_number = temp;
    	for ( int four = 0 ; four < 4 ; four++){
    		cur_number = cur_number << 16;
    		cur_number = cur_number + temp;
    	}
    	temp = temp + one;
    	inputa[i-1] = cur_number;
    }


    XTime t0, t1, t2, t3, t4;




    Xil_Out32(XPAR_MYIP_0_S00_AXI_BASEADDR, 0x00000004) ; // rst = 1
    Xil_Out32(XPAR_MYIP_0_S00_AXI_BASEADDR, 0x00000002) ; // data_in_st = 1
    XTime_GetTime(&t0);

    MoveDataDMA64(inputa, bram_a_destination, input_num);
    XTime_GetTime(&t1);

    int sw_done = 0;

    Xil_Out32(XPAR_MYIP_0_S00_AXI_BASEADDR, 0x00000001) ; // op_st = 1

    while(Xil_In32(XPAR_MYIP_0_S00_AXI_BASEADDR + 4) == 0) {
        if (!sw_done) {
            //fourbyfour_sw(inputa, SoftwareOutput, 32);
            sw_done = 1;   // 只算一次（或拆小塊多次算）
        }
        // 也可以在這裡做其他CPU任務
    }

    Xil_Out32(XPAR_MYIP_0_S00_AXI_BASEADDR, 0x00000000) ; // slv_reg0 = 0(no operation)

    int output_num = input_num -15;
    XTime_GetTime(&t2);
    MoveDataDMA64(bram_out0_destination, HardwareOutput, output_num) ;
    XTime_GetTime(&t3);
    fourbyfour_sw(inputa, SoftwareOutput, input_num);
    XTime_GetTime(&t4);

    for( int i = 0 ; i < input_num ; i++) {
    	printf("Hard outputMK2[%d] = %llu\n", i, HardwareOutput[i]);
    } // for
    for( int i = 15 ; i < input_num ; i++) {
    	printf("Soft outputMK2[%d] = %llu\n", i, SoftwareOutput[i]);
    } // for
    //******************time********************
    const u64 gticks1 = t1 - t0;
    const u64 us1     = (gticks1 * 1000000ULL) / COUNTS_PER_SECOND;
    const u64 cycles1 = us1 * 50ULL;

    const u64 gticks2 = t2 - t1;
    const u64 us2     = (gticks2 * 1000000ULL) / COUNTS_PER_SECOND;
    const u64 cycles2 = us2 * 50ULL;


    const u64 gticks3 = t3 - t2;
    const u64 us3     = (gticks3 * 1000000ULL) / COUNTS_PER_SECOND;
    const u64 cycles3 = us3 * 50ULL;                                  // 20ns/clk → 50 cycles/us

    const u64 gticks4 = t4 - t0;
    const u64 us4     = (gticks4 * 1000000ULL) / COUNTS_PER_SECOND;
    const u64 cycles4 = us4 * 50ULL;



    printf("first DMA time: %llu cycles (~%llu us)\n", cycles1, us1);
    printf("compute time: %llu cycles (~%llu us)\n", cycles2, us2);
    printf("second DMA time: %llu cycles (~%llu us)\n", cycles3, us3);
    printf("total time: %llu cycles (~%llu us)\n", cycles4, us4);
    return 0;
} // main()
